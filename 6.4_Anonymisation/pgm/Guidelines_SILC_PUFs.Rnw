\documentclass[article,nojss]{jss}
\usepackage{booktabs}

\usepackage{listings}
%\usepackage{natbib}
%\bibliographystyle{plainnat}

\lstset{language=R,
  			%frame=single,
				tabsize=2,
				%backgroundcolor=\color{lightgrey},
				%basicstyle=\scriptsize\ttfamily,
				basicstyle=\small\ttfamily,
				captionpos=b}
\lstset{breaklines=true} % break long lines



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% declarations for jss.cls %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% almost as usual
\author{Matthias Templ \\ Statistics Austria \& TU WIEN \And
Lydia Spies \\ Destatis \And 
Maxime Bergeat \\ INSEE \And Bernhard Meindl \\ Statistics Austria }
\title{Public Use Files for EU-SILC}

%% for pretty printing and a nice hypersummary also set:
\Plainauthor{Matthias Templ, Lydia Spies, Maxime Bergeat} %% comma-separated
\Plaintitle{Public Use Files for EU-SILC} %% without formatting
\Shorttitle{Public Use Files for EU-SILC} %% a short title (if necessary)

%% an abstract and keywords
\Abstract{
The simulation of synthetic EU-SILC data using synthetic data simulation methods are described and the corresponding code is embedded in this paper. 
Basically, the newest version of the \proglang{R} package \pkg{simPop} is used for simulating EU-SILC synthetic data. 
%\textcolor{red}{TODO: A wrapper function tailored specifically towards EU-SILC data for convenience and ease of use is presented, as well as} 
Detailed instructions for performing each of the four involved data generation steps separately and for the creation of the public use file are given. In addition, the data utility is discussed.
}
\Keywords{\proglang{R}, synthetic data, simulation, survey statistics, EU-SILC}
\Plainkeywords{R, synthetic data, simulation, survey statistics, EU-SILC} %% without formatting
%% at least one keyword must be supplied

%% publication information
%% NOTE: Typically, this can be left commented and will be filled out by the technical editor
%% \Volume{13}
%% \Issue{9}
%% \Month{September}
%% \Year{2004}
%% \Submitdate{2004-09-29}
%% \Acceptdate{2004-09-29}

%% The address of (at least) one author should be given
%% in the following format:
\Address{
  Matthias Templ\\
  CSTAT - Computational Statistics \\
  Institute of Statistics \& Mathematical Methods in Economics \\
  Vienna University of Technology \\
  Wiedner Hauptstr. 8-10 \\
  1040 Vienna, Austria \\
  Tel. +43 1 58801 10715 \\
  e-mail: matthias.templ@tuwien.ac.at \\
  and \\
  Statistics Austria \\
  Guglgasse 13 \\
  1110 Vienna, Austria \\
  \vspace{0.5cm}
  
  Lydia Spies \\
  Destatis \\
  Gustav-Stresemann-Ring 11 \\
  65189 Wiesbaden, Germany \\
  Tel. +49 611 753322 \\
  e-mail: lydia.spies@destatis.de\\
  
  \vspace{0.5cm}
  Maxime Bergeat \\
  INSEE \\
  18 Boulevard Alphonse Pinard \\
  75014 Paris, France \\
  Tel. +33 1 41176486 \\
  e-mail: maxime.bergeat@insee.fr\\
}
%% It is also possible to add a telephone and fax number
%% before the e-mail in the following format:
%% Telephone: +43/1/31336-5053
%% Fax: +43/1/31336-734

%% for those who use Sweave please include the following line (with % symbols):
%% need no \usepackage{Sweave.sty}

%%\VignetteIndexEntry{Simulation of EU-SILC Population Data: Using the R Package simPopulation}
%%\VignetteDepends{simPopulation}
%%\VignetteKeywords{R, synthetic data, simulation, survey statistics, EU-SILC}
%%\VignettePackage{simPopulation}

%% end of declarations %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%% additional packages
\usepackage{color}  % for comments


\begin{document}
\SweaveOpts{concordance=TRUE}
%\SweaveOpts{concordance=TRUE}

<<include=FALSE>>=
if (!require("knitr")) install.packages("knitr")
library(knitr)
opts_chunk$set(
concordance=TRUE
)
@




<<globalSettings3, echo=FALSE, include = TRUE, cache = FALSE>>=

knitr::opts_chunk$set(warning=FALSE, message=FALSE)
knitr::opts_chunk$set(fig.path="figures/") # cache=TRUE
knitr::opts_chunk$set(dev=c("pdf"))
knitr::opts_chunk$set(size="small")
options(width = 65)
#render_sweave()
@

<<options1, echo=FALSE, message=FALSE, warning=FALSE>>=
options(prompt = "R> ")
@

<<echo = FALSE>>=
rm(list=ls())
@



\section{Introduction}

We choose for EU-SILC public use files to generate synthetic data. For this purpose we use the R  package simPop \citep{alfons11b,simPop}. Contrary to LFS public use files we are generating in the scope of SGA "Public Use Files for Eurostat microdata" we will simulate fully synthetic data. A lot of major variables of SILC dataset consist of continuous variables, mainly information about individual and household income. "Traditional" anonymity models like $k$-anonymity are not made to deal with continuous indirectly identifying data, that is the major reason why we use a completely different approach in order to cancel disclosure risk. Moreover with synthetic data it is possible to keep the household structure in the public use files we are producing.

The public use files (PUFs) produced during this project are mostly intended for testing purposes and education. For example, researchers waiting to get access to actual scientific use files (SUFs) may already write codes for analysis and test them with PUFs. PUFs are not suitable for actual data analysis and are not intended to replace SUFs. PUFs can also be used at training courses teaching how to work with scientific use files. Since PUFs are available for everyone there is no way to control their use. Hence, a disclaimer is strongly recommended stating that:
\begin{enumerate}
  \item the user acknowledges that PUFs may only be used for strongly limited purposes
  \item Eurostat gives no warranty and does not carry any liability for the accuracy, reliability and content of the calculations based on PUFs or the conclusions drawn from it. These are to be produced at the sole risk and consideration of the user.
\end{enumerate}

This contribution shows how the creation of synthetic EU-SILC data is made in this project. The data simulation framework consists of four main steps:
\begin{enumerate}
  \item Setup of the household structure
  \item Simulation of categorical variables
  \item Simulation of (semi-)continuous variables
  \item Splitting (semi-)continuous variables into components
\end{enumerate}

Before the simulation some data preprocessing is necessary (see Section \ref{sec:pre}). The creation of final public use files is described in the following. At the end some additional variables (simply generated according to the distribution in the SUF) are added in the synthetic public use file.

Basically the objective is to obtain at the end a public use file that has the same structure as the already disseminated EU-SILC scientific use file. Consequently we use the SUF in some parts of the simulation in order to obtain a file that mimics the SUF. However in the main part of the simulation process described in Section \ref{sec:simul}, we also consider original microdata to build models. Then some post-processing (especially recoding) is made in order to mimic the SUF structure.

This paper does not go into detail on the statistical methodology of the framework. It is focused on the \proglang{R} code to generate synthetic datasets. For more details about methodology, the reader is referred to \citet{alfons11b,simPop}.

The \emph{European Union Statistics on Income and Living Conditions} (EU-SILC) 
is a panel survey conducted in European countries and serves as data basis for 
the estimation of social inclusion indicators in Europe. EU-SILC data are highly 
complex and contain detailed information on the income of the sampled 
individuals and households. More information on EU-SILC can be found in 
\citet{EU-SILC13}. 

In \citet{alfons11b}, three methods for the simulation of the net income of the 
individuals in the population are proposed and analyzed:
\begin{description}
  \item[MP] Multinomial logistic regression models with random draws from the 
  resulting categories. For the categories corresponding to the upper tail, the 
  values are drawn from a (truncated) generalized Pareto distribution, for the 
  other categories from a uniform distribution.
  \item[TR] Two-step regression models with trimming and random draws from the 
  residuals.
  \item[TN] Two-step regression models with trimming and random draws from a 
  normal distribution.
\end{description}
In this application, we use the multinomial logistic regression.

The first two steps of the analysis, namely the simulation of the household 
structure and additional categorical variables, are performed in exactly the 
same manner for the three scenarios. While the simulation of the income 
components is carried out with the same parameter settings, the results of 
course depend on the simulated income.


\section{Data preprocessing} \label{sec:pre}

With the following commands, necessary packages are loaded. Furthermore, the numeric value stored in \code{seed} will be used as seed for the random number generator in the simulation to make the results reproducible.

<<echo=FALSE, message=FALSE, warning=FALSE>>=
if (!require("devtools")) install.packages("devtools")
if (!require("sdcMicro")) install.packages("sdcMicro")
if (!require("simPop")) install.packages("simPop")
if (!require("parallel")) install.packages("parallel")
if (!require("laeken")) install.packages("laeken")
if (!require("Hmisc")) install.packages("Hmisc")
if (!require("stringr")) install.packages("stringr")
if (!require("simFrame")) install.packages("simFrame")
set.seed(23456)
@

The use of the following package versions (and associated dependent packages) or higher versions is recommended:

<<sessioninfo, echo=FALSE, results="asis">>=
utils::toLatex(sessionInfo())
@


<<echo=FALSE>>=
hook_output <<- knit_hooks$get('output')
knit_hooks$set(output = function(x, options) {
  # this hook is used only when the linewidth option is not NULL
  if (!is.null(n <- options$linewidth)) {
    x = knitr:::split_lines(x)
    # any lines wider than n should be wrapped
    if (any(nchar(x) > n)) x = strwrap(x, width = n)
    x = paste(x, collapse = '\n')
  }
  hook_output(x, options)
})
@

First ensure that your current working directory in \proglang{R} is set correctly. 
There is few differences in the data sets. This document considers two versions, the Austrian case (\code{country $=$ "Austria"}) and the French data  (\code{country $=$ "France"}).

<<person, echo=FALSE>>=
country <- "Austria"
year <- 2013
myfactor <- 1
calib <- TRUE
@


Please change the path accordingly.

\subsection{Read data and select variables}

The data provided by the SILC group at Statistics Austria contains the merged Austrian SILC information in SPSS. To read the data it may convenient to install package \pkg{haven} first. Please set the file path accordingly.

<<importdata, cache = FALSE, include = TRUE>>=
if(country == "Austria"){
  orig_file <- "~/workspace/sga_sdc/silcPop/new_workfile.RData"
}

if(country == "France"){
  orig_file <- "Z:/Eurostat/FPA/Donn?es/SILC 2012/Fichiers originaux/indiv_complet_csv.csv"
}
@

Now use the helper function \code{loadSILC} to load your data. Note that the data can be stored  in csv, sav, rda or RData file formats. In the following example data is loaded where all variables are contained in one file.

<<importdata2, cache = TRUE, include = TRUE, message=FALSE, warning=FALSE>>=
library("simPop")
x <- loadSILC(orig_file)
@


Note that in some countries the data set is stored in four different files separating individual and household data (dfile, hfile, pfile, rfile). In this case we first need to merge the four files to one single file.

Here is a code to see how this might work when you have separated files. The code works for file formats csv, sav, rda and RData. This code is here applied to load scientific use files that are used in data post-processing in order to get a public use file that mimics the structure of scientific use files. First we specify the directory and filename.

<<import data 2, eval=TRUE, cache=TRUE, include = TRUE>>=
if(country == "Austria"){
  filed <- "~/workspace/sga_sdc/eurostatFormatData/2013/zielvar_d_eurostat2013.sav"
  filer <- "~/workspace/sga_sdc/eurostatFormatData/2013/zielvar_r_eurostat2013.sav"
  filep <- "~/workspace/sga_sdc/eurostatFormatData/2013/zielvar_p_eurostat2013.sav"
  fileh <- "~/workspace/sga_sdc/eurostatFormatData/2013/zielvar_h_eurostat2013.sav"
  suf4 <- loadSILC(filed = filed, filer = filer, filep = filep, fileh = fileh)
}
if(country == "France"){
## please use appropriate names for the csv files
  filed <- "~Z:/Eurostat/FPA/Donn?es/SILC 2012/SUFs/UDB_c12D_ver 2012-3 from 01-03-15.csv"
  filer <- "Z:/Eurostat/FPA/Donn?es/SILC 2012/SUFs/UDB_c12R_ver 2012-3 from 01-03-15.csv"
  filep <- "Z:/Eurostat/FPA/Donn?es/SILC 2012/SUFs/UDB_c12P_ver 2012-3 from 01-03-15.csv"
  fileh <- "Z:/Eurostat/FPA/Donn?es/SILC 2012/SUFs/UDB_c12H_ver 2012-3 from 01-03-15.csv"
}
@


<<read4>>=
suf4 <- loadSILC(filed = filed, 
                 filer = filer, 
                 filep = filep, 
                 fileh = fileh)  
@

Next data are merged to one file.

<<mergeSILC>>=
suf <- mergeSILC(filed = suf4[["d"]], 
                 filer = suf4[["r"]], 
                 fileh = suf4[["h"]], 
                 filep = suf4[["p"]])
@

<<echo = FALSE>>=
if(country == "Austria"){
  suf.d <- suf4[["d"]]
  suf.r <- suf4[["r"]]
  suf.h <- suf4[["h"]]
  suf.p <- suf4[["p"]]
}
# suf <- x[,colnames(suf) %in% colnames(x)]
@


Check which variable of the SUF are not present in the original data. Note this happens if countries store their data not using standards for EU-SILC.

<<check>>=
cn <- checkCol(x, suf)
@

In the following, some variables are needed which might not be present for all countries. 
They are also not listed, e.g. at \\ 
http://www.gesis.org/missy/eu/files/documents/EU-SILC/MISSY\_Codebook\_cross\_2011.pdf
For the Austrian data, e.g., we add

<<>>=
if(country == "Austria"){
  ## rx020, px020 age at the end of the income reference period
  suf$rx020 <- getAge(suf$rb080, year)
  suf$px020 <- suf$rx020
  ## household identification number
#  suf.r$rx030 <- 
}   
@



We extract the most important variables and convert some variables to the appropriate format if necessary.


<<silc, include = TRUE>>=
eusilc <- chooseSILCvars(x, country = "Austria")
@



\subsection{Adding some useful variables and minor modifications}

Various useful helper functions are written and included in simPop package. 
Application of these utility functions can not be seen in the following, but is available when typing 
\code{help('getAge').

Following modifications are done
\begin{itemize}
  \item In the EU-SILC data set, only the birth is given. We add the age variable.
  \item The gender is coded with 1's and 2's. It is changed to \textit{female} and \textit{male}.
  \item The household size is only indirectly included in original dataset (through the household ID), but we calculate and add it in the original dataset.
  \item We slightly modify \code{pl031} (economic status).
Variable \code{pb220a} (citizenship) is very sparse. We make broader categories. Note that this is country-specific.
  \item Occupation (\code{pl051} variable) and NACE (\code{pl111} variable) are very detailed in original microdata. Given these important variables are then simulated, we need to make global recoding to make broader categories. How the recoding has to be done is country specific. Recoding of Occupation to 1-digit version
  \item Recoding of NACE code - this may be country-specific.
  \item Further, we need to compute the summarized personal gross income as well as the summarized household incomes. We choose to use the gross income variables instead of the net income variables because the equivalised disposable income is computed from the gross income variables. Moreover the net income variables are not compulsory and therefore some countries do not transmit them. 
  \item For latter simulation use, we need the categorized incomes as well because they are used in the simulation described in next section.
The gross income categories are constructed internally with the function \code{getBreaks()}, where default breakpoints based on quantiles are computed. Quantiles are based on the original weighted sample. In this example, the argument \code{upper} is set to \code{Inf} to avoid problems with different maximum values in the three synthetic populations, and, internally, the argument \code{equidist} is set to \code{FALSE}  such that non-equidistant probabilities as described in \citet{alfons11b} are  used for the calculation of the quantiles. The household income is separated between ``positive income'' called \code{hgrossIncome} and ``negative income'' paid by the household, e.g. taxes, called \code{hgrossminus}.
\end{itemize}


<<addvars, eval=TRUE, cache=FALSE, include = TRUE>>=
eusilc <- modifySILC(x = eusilc, country = "Austria")
breaks <- c(min(eusilc$age, na.rm = TRUE), seq(15, 65, 15), max(eusilc$age, na.rm=TRUE))
eusilc$ageCat <- cut(eusilc$age, 
                       breaks=breaks, include.lowest=TRUE)
@




For simulation purposes we need to include an extra level for the missing values (NA's) in the categorical variables we are going to simulate later on in section \ref{sec:simul}.

%' 
%' #' <<eval=TRUE, cache=FALSE, echo=FALSE>>=
%' #' factorNA <- function(x, always = FALSE, newval = NA) {
%' #'   always <- isTRUE(always)
%' #'   if(is.na(newval)){
%' #'     if(is.factor(x)) {
%' #'       l <- levels(x)
%' #'       if(NA %in% l || !(always || any(is.na(x)))) x
%' #'       else {
%' #'         l <- c(l, NA)
%' #'         factor(x, levels=c(levels(x), NA), exclude=c())
%' #'       }
%' #'     } else {
%' #'       if(always) {
%' #'         factor(c(NA, x), exclude=c())[-1] # little trick
%' #'       } else factor(x, exclude=c())
%' #'     }
%' #'   } else { # newval is a character
%' #'     if(!is.character(newval)) stop("newval must be NA or a character string")
%' #'     if(is.factor(x)) {
%' #'       l <- levels(x)
%' #'       l <- c(l, newval)
%' #'       x <- as.character(x)
%' #'       x[is.na(x)] <- newval
%' #'       factor(x)
%' #'     }
%' #'   }
%' #' }
%' #' @


<<factorNAs, cache=FALSE>>=
vars <- c("pl031", "pb220a", "pb190", "pl051", "pe040", "pl111")
for(i in vars){
  eusilc[, i] <- factorNA(eusilc[, i], newval = "NAs")
}
@



The data set is now prepared before starting generation of synthetic data. The basic structure is as seen in the following.

<<strdata, linewidth=72>>=
str(eusilc)
@ 


\section{Simulation of the population} \label{sec:simul}

%The variable names of the example data set are used as default values in the function arguments. It would therefore mostly not be necessary to write them explicitely in the function calls, but in order to demonstrate how these arguments are used, the names of the involved variables are always supplied in the commands called.
 
First, it is important to check the platform since of parallel computing tasks. Windows cannot fork and it is slow for parallel computing with data set of moderate or large size. Thus if the platform is Microsoft Windows we use only one CPU, otherwise the number of CPU's are set to maximum of CPU's on your computer minus one.

<<eval=TRUE, cache=FALSE, include = TRUE, echo=FALSE, linewidth=75>>=
if(.Platform$OS.type == "windows"){
  cat("simPop provides parallel computing. However, forking and is not efficient within your operating system with moderate or large data files. Therefore the use of one CPU is faster than using more than one. On Linux and OS X the number of CPU's used is the maximum of CPU's minus one.")
  cpus <- 1
} else {
  cat("simPop is parallel. The maximum number of CPU's minus one is used for computations")
  cpus <- NULL
  number <- parallel::detectCores() - 1
  cat(paste("\n On the machine used to generate this document, the number of parallel processes used is", number))
}
@


The simulation process consists of these steps:
\begin{enumerate}
  \item Setup of the household structure for a complete population
  \item Simulation of categorical variables 
  \item Simulation of (semi-)continuous variables 
  \item Splitting (semi-)continuous variables into components 
\end{enumerate}

After the main simulation described in this section a sample is selected from the synthetic population and some other variables are simulated in the resulting sample with a simpler method described in next section. This sample is intended to be disseminated as a synthetic public use file. The method is based on simulation of a population. One of the reasons for that is because we use logistic multinomial regression models in the simulation process and it is not easy to take sampling weights into account when building regression models.

In case of large populations (like Germany or France), the division of the household weight (=\code{db090}) by a factor, e.g. 10, is needed if the memory size on the computer is too small. Using a factor of 10 means that a population of size $N/10$, with $N$ the number of inhabitants in the corresponding country, is simulated. We use the factor defined above.


<<eval=TRUE, cache=FALSE, include = TRUE>>=
eusilc$db090 <- eusilc$db090 / myfactor
@

\subsection{Setup of the household structure for a complete population}
We specify the input, and provide information on household ID, household size, strata (optionally) and sampling weights before simulation of a synthetic population with some basic variables.

<<eval=TRUE, cache=FALSE, include = TRUE>>=
inp <- specifyInput(data=eusilc, 
                    hhid="db030", 
                    hhsize="hsize", 
                    strata="db040", # if country level, strata could be skipped
                    weight="db090")
inp
@

% 
% #' <<echo = FALSE>>=
% #' if(person == "matthias"){
% #' inp <<- specifyInput(data=eusilc, 
% #'                     hhid="db030", 
% #'                     hhsize="hsize", 
% #'                     strata="db040", # if country level, strata could be skipped
% #'                     weight="db090")
% #' }
% #' save(inp, file="imp.RData")
% #' @

The first step of the analysis is to set up the basic household structure using the function \code{simStructure()}. The argument \code{additional} specifies the variables that define the household structure in addition to the household size. We have chosen to generate in this step the age and gender variables. 

<<simStructure2, eval=TRUE, cache=TRUE, include = TRUE>>=
eusilcP <- simStructure(inp, method="direct", 
                  basicHHvars=c("age", "rb090") )
eusilcP
@

The methodology for simulating these variables is:
\begin{enumerate}
  \item Define in original sample data stratum defined by combination of household size variable and variable defined in \code{strata} argument. We use here the region. 
  \item Create randomly a population that has the same distribution for the household size and region variables.
  \item For each simulated household, select randomly in the original microdata one household of the same region and the same size. 
  \item All members of the simulated household get the same individual characteristics (variables defined in \code{additional} argument and sampling weight) than the original one.
\end{enumerate}

Sampling weights are taken into account to reflect distribution of region, household size, age and gender variables in the synthetic population. For more details see also \citet{alfons11b}.

At this moment variables generated in the synthetic population are listed in Table \ref{tab:varHHStruc}.

\begin{table}[t!]
\centering
\caption{\label{tab:varHHStruc}Variables simulated when generating the household structure}
\begin{tabular}{llll}
\toprule
\textbf{Variable} & \textbf{Name} & \textbf{Type} \\
\midrule
Region & \code{db040} & Categorical \\
Household size & \code{hsize} & Categorical \\
Age & \code{age} & Categorical \\
Gender & \code{rb090} & Categorical \\
Sampling weight & \code{db090} & Continuous \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Simulation of categorical variables}

Additional categorical variables are then simulated using the function 
 \code{simCategorical()}. The argument \code{additional} specifies the variables to 
be simulated in this step. Function argument \code{regModel} is used 
to specify the predictors and/or the regression model. Possible values are \code{basic} (only the basic structural variables are used as a predictor), \code{available} (all available predictors are used) or an object of class \code{formula} (specifying a formula). We choose \code{available}.


<<simCat6, eval=TRUE, cache=TRUE, include = TRUE, linewidth=72, results='hide'>>=
eusilcP <- simCategorical(eusilcP,
                          additional = c("pl031","pb220a", "pb190",
                                         "pl051", "pe040", "pl111"),
                          regModel = rep("available", 6),
                          nr_cpus=cpus, MaxNWts=5000 )
## for latter use:
age <- as.numeric(as.character(pop(eusilcP)$age))
breaks <- c(min(age, na.rm = TRUE), seq(15, 65, 15), max(age, na.rm=TRUE))
ageCat <- cut(age, breaks=breaks, include.lowest=TRUE)
pop(eusilcP, var="ageCat") <- ageCat

eusilcP 
@

In this step, six categorical variables listed in the \code{additional} argument are simulated. The methodology for the simulation is as follows:

\begin{enumerate}
  \item Use of multinomial logistic regression modeling in order to estimate the distribution of the variable to be simulated.
  \item The response variable is the variable to be simulated. Explanatory variables are the household size, simple variables generated with the household structure (here age and gender) and already generated categorical variables. Variables (and the order) simulated in this step are listed in \code{additional} argument.
  \item Consequently order of simulation is important. In this case, \code{pl031} is an explanatory variable for simulation of \code{pb220a}, \code{pl031} and \code{pb220a} are used for simulation of \code{pb190} variable and so on. 
  \item Logistic regression models are fitted for each stratum independently. The stratum is defined for the whole simulation process: we use here the region (\code{db040}) variable. The stratum variable is defined in the \code{specifyInput()} function.
  \item After estimation of the conditional distribution of the response variable, random draws from this conditional distribution are taken to simulate the variable.
\end{enumerate}

At this moment variables generated in the synthetic population are listed in Table \ref{tab:VarCateg}. Some variables are recoded in order to have broader categories for the simulation: See previous Section.

\begin{table}[t!]
\centering
\caption{Variables simulated when simulating categorical variables}
\label{tab:VarCateg}
\begin{tabular}{llll}
\toprule
\textbf{Variable} & \textbf{Name} & \textbf{Type} \\
\midrule
Economic status & \code{pl031} & Categorical \\
Citizenship & \code{pb220a} & Categorical \\
Marital status & \code{pb190} & Categorical \\
Education & \code{pe040} & Categorical \\
Occupation & \code{pl051} & Categorical \\
NACE & \code{pl111} & Categorical \\
\bottomrule
\end{tabular}
\end{table}


\subsection{Simulation of continuous variables}

The next step consists in simulation of continuous variables, mainly information about income. We choose to use gross income components. First step is to compute total personal and household income. For household income positive and negative components are separated.

We use the function \code{simContinuous()} to simulate total income variables according to this methodology, close to the one used for simulation of main categorical variables: 

\begin{enumerate}
  \item Use of multinomial logistic regression modeling in order to estimate the distribution of the variable to be simulated.
  \item The response variable is a discretized version of the continuous variable to be simulated. The option \code{zeros= TRUE} is used in order to add a special category for zero values for semi-continuous variables.
  \item Explanatory variables are simple variables generated with the household structure (here age and gender - \code{rb090}) and all previously variables defined in the \code{regModel} argument. Here we use occupation and citizenship. Moreover the household size is used when simulating household income. 
  \item Logistic regression models are fitted for each stratum independently. The stratum is defined for the whole simulation process: we use here the region (\code{db040}) variable. The stratum variable is defined in the \code{specifyInput()} function.
  \item After estimation of the conditional distribution of the response variable, random draws from this conditional distribution are taken to simulate the discretized version of the continuous variable.
  \item To get at the end a continuous variable a random draw from a generalized Pareto distribution (for the highest income category) or from a uniform distribution (for all other categories) is taken. 
  \item The \code{byHousehold = 'random'} option is used in order that every member of a household has the same household income.
\end{enumerate}

<<breaks>>=
breaks <- getBreaks(eusilc$pgrossIncome, eusilc$rb050, 
                      upper = Inf, equidist = FALSE, zeros = TRUE)
breakshh <- getBreaks(eusilc$hgrossIncome, eusilc$rb050, 
                      upper = Inf, equidist = FALSE, zeros = TRUE)
breakshhm <- getBreaks(eusilc$hgrossminus, eusilc$rb050, 
                      upper = Inf, equidist = FALSE, zeros = TRUE)
@


<<simCont, eval=TRUE, cache=TRUE, include = TRUE, message=FALSE, warning=FALSE, linewidth=75, results='hide'>>=
eusilcP <- simContinuous(eusilcP, breaks = breaks, additional = "pgrossIncome",
                          upper = 200000, equidist = FALSE, 
                          zeros=TRUE, nr_cpus=cpus, MaxNWts=10000,
                          regModel = formula(~ age + rb090 + pl031 + pb220a))

## truncate personal income
p <- pop(eusilcP)$pgrossIncome
m <- max(samp(eusilcP)$pgrossIncome)
p[p > m] <- m
pop(eusilcP, var="pgrossIncome") <- p

eusilcP <- simContinuous(eusilcP, breaks = breakshh, additional = "hgrossIncome",
                          upper = 200000, equidist = FALSE, zeros=FALSE,
                          nr_cpus=cpus, MaxNWts=10000,
                          regModel = formula(~ hsize + age + rb090 + pl031 + pb220a),
                          byHousehold = "random")
## truncate hh income
p <- pop(eusilcP)$hgrossIncome
m <- max(samp(eusilcP)$hgrossIncome)
p[p > m] <- m
pop(eusilcP, var="hgrossIncome") <- p

eusilcP <- simContinuous(eusilcP, breaks = breakshhm, additional = "hgrossminus",
                          upper = 200000, equidist = FALSE, zeros=FALSE,
                          nr_cpus=cpus, MaxNWts=10000,
                          regModel = formula(~ hsize + age + rb090 + pl031 + pb220a),
                          byHousehold = "random")
eusilcP 
@

Variables simulated in this step are listed in Table \ref{tab:VarCont}.


\begin{table}[t!]
\centering
\caption{\label{tab:VarCont}Variables simulated when simulating continuous variables}
\begin{tabular}{llll}
\toprule
\textbf{Variable} & \textbf{Name} & \textbf{Type} \\
\midrule
Total personal income & \code{pgrossIncome} & Semi-continuous \\
Household income (total of positive components) & \code{hgrossIncome} & Semi-continuous \\
Household income (total of negative components) & \code{hgrossminus} & Semi-continuous \\
\bottomrule
\end{tabular}
\end{table}


\subsection{Simulation of income components}

Total income variables are then splitted into income components with the \code{simComponents()} function. 

Simulation of income components is based on this methodology:

\begin{enumerate}
  \item The estimation is made for each group defined with the variable in \code{conditional} argument. For personal income we form groups according to economic status (\code{pl031} variable). For household income the household size is used to form the groups. These variables are already simulated in previous steps for the synthetic population.
  \item For each record of the population inside one group, select randomly a record from the original sample that has the same characteristics for the \code{conditional} variable. Sampling weights are taken into account to select the donor record.
  \item For the simulated record impute all income components proportions from the original record.
  \item If one income component is not disseminated in the SUF (all records have a NA for instance), it shouldn't be simulated here (otherwise it will lead to an error).
\end{enumerate}

<<simCompP, eval=TRUE, cache=TRUE, include = TRUE>>=
if(country == "France"){
  ## in France "py021g" is missing
  pcomponents <- c("py010g","py050g","py080g",
                 "py090g","py100g", "py110g","py120g",
                 "py130g","py140g")

} else {
  pcomponents <- c("py010g","py021g","py050g","py080g",
                   "py090g","py100g", "py110g","py120g",
                   "py130g","py140g")
}

eusilcP <- simComponents(eusilcP, 
                          total = "pgrossIncome", 
                          components = pcomponents, 
                          conditional = c("pl031","ageCat"))
@

In order to get the same household income components for all household members we create household datasets. This is done by just keeping the first household member of every household in the sample and in the population data.

% 
% #' <<eusilcH, eval=TRUE, cache=TRUE, include = TRUE>>=
% #' eusilcH <- eusilcP
% #' 
% #' ## TODO: change this to samp() and pop()
% #' eusilcH@sample@data <- eusilcH@sample@data[!duplicated(eusilcH@sample@data$db030)]
% #' eusilcH@pop@data <- eusilcH@pop@data[!duplicated(eusilcH@pop@data$db030)]
% #' @
% #' 
% #' We then simulate the household income components with household size as conditional variable as described above.
% #' 
% #' <<eusilcHcomp, eval=TRUE, cache=TRUE, include = TRUE>>=
% #' hcomponents <- c("hy040g", "hy050g", "hy060g", "hy070g",
% #'                  "hy080g", "hy090g", "hy110g")
% #' eusilcH <- simComponents(eusilcH, 
% #'                          total = "hgrossIncome", components = hcomponents, 
% #'                          conditional = "hsize")
% #' 
% #' hminuscomponents <- c("hy120g","hy130g","hy140g")
% #' eusilcH <- simComponents(eusilcH, 
% #'                          total = "hgrossminus", components = hminuscomponents, 
% #'                          conditional = c("hsize"))
% #' @
% #' 
% #' Afterwards the simulated household income components are merged back to the population data on person level.
% #' 
% #' <<eusilcHtoP, eval=TRUE, cache=TRUE, include = TRUE, cache.lazy=FALSE>>=
% #' vars = c("db030", "hy040g", "hy050g", "hy060g", "hy070g", "hy080g",
% #'          "hy090g", "hy110g", "hy120g", "hy130g", "hy140g")
% #' hhIncome <- pop(eusilcH, var=vars)
% #' 
% #' eusilcP@pop@data <- merge(x=eusilcP@pop@data,
% #'                            y=hhIncome,
% #'                            by="db030")
% #' @

<<>>=
hcomponents <- c("hy040g", "hy050g", "hy060g", "hy070g",
                "hy080g", "hy090g", "hy110g")
eusilcP <- simComponents(eusilcP, 
                        total = "hgrossIncome", components = hcomponents, 
                        conditional = c("hsize", "db040"))

hminuscomponents <- c("hy120g","hy130g","hy140g")
eusilcP <- simComponents(eusilcP, 
                        total = "hgrossminus", components = hminuscomponents, 
                        conditional = c("hsize","db040"))
@


<<removeHH, echo = FALSE>>=
## delete unnecessary files
rm(hhIncome,eusilcH)
@

$39$ variables are simulated in this step, listed in \code{components} vectors. For more information see Eurostat (2013).

<<store new file, echo=FALSE, cache=TRUE>>=
save(eusilcP, file = "eusilcP.RData")
@


\section{Data post-processing} \label{sec:post}

The synthetic population has the following variables included at this moment:

<<showP, linewidth=72>>=
eusilcP
@

To finalize the synthetic PUF before dissemination, we need to select a sample from synthetic population. We will also add other variable in the sample synthesized in a simpler way (without modeling).

\subsection{Select a sample from synthetic population}

We need to select a sample from the synthetic population. We choose to use stratified group sampling. We use the region variable (\code{db040}) for stratification. We select households and then all members of one select household are present in the synthetic sample. Consequently number of households in the synthetic PUF is the same as in original microdata, but number of individuals may differ.


<<drawSample, linewidth=72>>=
## ----table of number of households per region (used drawing the puf)
x2 <- data.table(x[,c("db040","db030")])
setkey(x2, db030)
hh <- x2[, unique(db040), by = db030]
tab <- table(hh$V1)
## number of households in all districts
tab
tab <- as.numeric(table(hh$V1))
## number of households:
sum(tab)

## stratified group sampling, equal size
set.seed(23456)
dim(pop(eusilcP))
class(pop(eusilcP))
puf <- draw(data.frame(pop(eusilcP)), 
             design = "db040", 
             grouping = "db030", 
             size = tab)

## rename weight vector
colnames(puf)[which(colnames(puf) == ".weight")] <- "rb050"
puf$rb050 <- puf$rb050 * myfactor

## size of the data
dim(puf)
nrow(puf[!duplicated(puf$db030), ])
@


<<>>=
if(calib){
  totals1 <- tableWt(eusilc[, c("rb090","db040")], weights=eusilc$rb050)
  weights2 <- calibSample(puf, as.data.frame(totals1), w = puf$rb050)  
  puf$rb050_calib <- weights2$final_weights
}
@

If your sampling weights differ a lot from your original data set, you didn't specified the correct sampling design (country specific) and you may use another sampling design to draw from your population.
Lets check this, first on the next graphics, and also on the output of \code{summary}.

<<sumamries, fig.height = 5, out.width='9cm', echo = FALSE, fig.align='center'>>=
gg <- ggplot(x, aes(x = rb050)) + geom_density(data = x, aes(x = rb050), color = "blue") +  geom_density(data = data.frame(puf), aes(x = rb050), color = "red")
print(gg)
summary(x$rb050)
summary(puf$rb050)
@



\subsection{Preparation of the scientific use file}

The next step is to add additional variables to the Public Use File. We have decided to create most of these variables from the scientific use file in order to be consistent with this file and to mimic the SUF structure. Therefore some preparative modifications to the Scientific Use File are necessary.

<<rowsumspgi, linewidth=72, tidy = TRUE>>=
if(is.factor(suf$py010g)){
  require(dplyr)
  fac <- c("py010g", "py021g", "py050g", "py080g", "py090g", "py100g", "py110g", 
           "py120g", "py130g", "py140g", "hy080g", "rb050", "pb040")
  suf <- suf %>% mutate_each_(funs(as.character), fac) %>% mutate_each_(funs(as.numeric), fac)
}

suf$pgrossIncome <- rowSums(suf[, c("py010g","py021g","py050g","py080g",
                                    "py090g","py100g", "py110g","py120g",
                                    "py130g","py140g")], na.rm=TRUE)

suf$hgrossIncome <- rowSums(suf[, c("hy040g","hy050g","hy060g","hy070g","hy080g",
                                    "hy090g","hy110g")], na.rm = TRUE)
                                 
@



\subsection{Add other variables}

First some variables are added or renamed in order to have the same structure than scientific use files disseminated to researchers. Variables common to several public use files are computed here. Furthermore in the simulated categorical variables the level "NA" is removed again.


<<addvarspuf, cache=TRUE, linewidth=72>>=
puf$pb040 <- puf$rb050
puf$hb030 <- puf$db030
puf$px030 <- puf$db030
puf$rx030 <- puf$db030
#puf$pb030 <- puf$pid
#puf$rb030 <- puf$pid
### NEW:
puf$hid <- as.character(puf$pid)
puf$hid <- as.numeric(sapply(puf$hid, function(x) substr(x, 1, nchar(x)-2)))
puf$hx040 <- puf$hsize
puf$pb150 <- puf$rb090

## add age variables:
if(!is.numeric(puf$age)) {
  puf$rx020 <- as.numeric(as.character(puf$age))
} else {
   puf$rx020 <- puf$age
}
puf$px020 <- puf$rx020

## add age difference (if rx010 is provided):

if(country == "Austria"){
  ## date of interview not found in suf
  puf$rx010 <- puf$rx020
} else {
  tab <- wtd.table(suf$rx010 - suf$rx020, weights = suf[, "rb050"], type = "table")
  p <- tab/sum(suf[, "rb050"])
  age.dif <- sample(x = c(0, 1), size = dim(puf)[1], prob = p, replace = TRUE)
  puf$rx010 <- puf$rx020 + age.dif
}

## add the equivalised household size
puf$hx050 <- eqSS("db030", "rx020", data=puf)


## compute income variables
sum.pgrossIncome <- aggregate(puf[,c("py010g","py021g","py050g","py080g","py090g",
                                     "py100g","py110g","py120g","py130g","py140g")],
                              by=list(puf$db030),FUN=sum, na.rm=TRUE)
names(sum.pgrossIncome)[names(sum.pgrossIncome)=="Group.1"] <- "db030"
puf <- merge(x=puf,y=sum.pgrossIncome,by="db030",suffixes=c("",".hh"))

## hy010: total household gross income 
puf$hy010 <- puf$hy040g + puf$hy050g + puf$hy060g + puf$hy070g + puf$hy080g + 
             puf$hy090g + puf$hy110g + puf$py010g.hh + puf$py021g.hh + 
             puf$py050g.hh + puf$py080g.hh + puf$py090g.hh +
             puf$py100g.hh + puf$py110g.hh + puf$py120g.hh + 
             puf$py130g.hh + puf$py140g.hh

## hy020: total disposable household income
puf$hy020 <- puf$hy010 - puf$hy120g - puf$hy130g - puf$hy140g

## hy022: total disposable household income before social transfers 
## other than old-age and survivor?s benefits
puf$hy022 <- puf$hy040g + puf$hy080g + puf$hy090g + puf$hy110g - puf$hy120g - 
             puf$hy130g - puf$hy140g + puf$py010g.hh + puf$py021g.hh + 
             puf$py050g.hh + puf$py080g.hh + puf$py100g.hh + puf$py110g.hh

## hy023: total disposable household income berfore social transfers 
## including than old-age and survivor's benefits

puf$hy023 <- puf$hy040g + puf$hy080g + puf$hy090g + puf$hy110g - puf$hy120g - 
             puf$hy130g - puf$hy140g + puf$py010g.hh + puf$py021g.hh + 
             puf$py050g.hh + puf$py080g.hh

keep <- names(puf)[str_sub(names(puf), start= -3)!=".hh"]
puf <- subset(puf,select=keep)

if(country == "France"){
  # add a NA variable for py021g in order to mimic the SUF
  puf$py021g <- as.numeric(rep(NA, length(puf$db030)))
}

## remove level 'NAs'
puf[puf == "NAs"] <- NA
w <- apply(puf, 2, function(x) "NAs" %in% levels(x))
w <- which(unlist(lapply(puf, function(x) "NAs" %in% levels(x))))
for(j in w){
  puf[, j] <- puf[, j][drop = TRUE]
}
@

For now there are
\Sexpr{ncol(puf)} 
variables in the synthetic sample. The final step is to add to the synthetic sample some less important variables that are generated in a simple way. We have decided to create these variables from the scientific use file in order to be consistent with this file and to mimic the SUF structure. For most variables we use \code{conditional.dis()} function that makes the following:

\begin{enumerate}
  \item Estimation of the distribution of the variable to be generated grouping by the categorical variable in \code{conditional} argument.
  \item Random draws from the conditional distribution.
  \item The conditional variables are for household variable the total household income ($5$ categories) and the personal total income in $5$ categories for personal data.
\end{enumerate}

We use for some non-significant variables the \code{univariate.dis} function. That makes the same job without grouping by a \code{conditional} variables. The variable distribution will be the same in expectation that the distribution in the scientific use file. In this step all variables that are present in the scientific use files and not already simulated in previous steps are generated. 

Some variables derived from other ones cannot be simulated in a simple way because it will lead to inconsistencies (e.g. if the year where highest qualification was achieved is before birth date!). These variables are not simulated and bus me deleted from the scientific use file in a first place. 

List of variables to be deleted (to be checked) in the scientific use file that won't be simulated in the public use file
\begin{enumerate}
  \item All flag variables (variables finishing with "\_f")
  \item All net income components given we will only simulate gross income variables (variables finishing with "n")
  \item All variables about sampling design that is not the same to build the PUF: DB050, DB060, DB070, DB075, DB100, DB110, DB120, DB130, DB135
  \item All IDs about other household members: PB160, PB170, PB180, HB070(?), HB080(?), HB090(?), RB220, RB230, RB240, RB270
  \item Country of birth given it is highly correlated to nationality (?): PB210
  \item Year when highest level of education was attained: PE030
  \item PL073, PL074, PL075, PL076, PL080, PL085, PL086, PL087, PL088, PL089, PL090 are related via an accounting equality (sum= 12 months). They cannot be simulated independently.
  \item PL200: number of years spent in paid work
  \item PL211A - PL211L (monthly main activity) are highly correlated with yearly activity (? to be checked).
  \item HH031 year of contract or purchasing or installation
  \item RB031 year of immigration
  \item Non-necessary (like longitudinal) weights: DB080, RB060, RB062, RB063, RB064, RL070
  \item year and month moved in/out (or died): RB180, RB190, RB140, RB150
\end{enumerate}

The variables that won't be simulated are suppressed using the following code.

<<cache=TRUE, linewidth=72>>=
delete <- c(names(suf)[str_sub(names(suf), start= -2)=="_f"],
            names(suf)[str_sub(names(suf), start= -2)=="_i"],
            names(suf)[str_sub(names(suf), start= -1)=="n"],
            "db050","db060","db070","db070","db075",
            "db100","db110","db120","db130","db135",
            "pb160","pb170","pb180","hb070","hb080",
            "hb090","rb220","rb230","rb240","rb270",
            "pb210","pe030","pl073","pl074","pl075",
            "pl076","pl080","pl085","pl086","pl087",
            "pl088","pl089","pl090","pl200","pl211a",
            "pl211b","pl211c","pl211d","pl211e","pl211f",
            "pl211g","pl211h","pl211i","pl211j","pl211k","pl211l",
            "hh031","rb031","db080","rb060","rb062",
            "rb063","rb064","rl070","rb180","rb190",
            "rb140","rb150")

simulated <- colnames(puf)
@

We create the rest of the variables.

<<createRestvars>>=
vars <- function(char1 = "d", p = puf.d, s = suf){
  nam <- names(s)[substr(names(s), 1, nchar(char1)) == char1 & 
                      !(names(s) %in% names(p)) &
                      !(names(s) %in% delete) & !(names(s) %in% simulated)]
  return(nam)
}

## d-file: household register
puf.d <- puf[!duplicated(puf$db030),substring(names(puf),1,1)=="d"]
ss <- suf[!duplicated(suf$db030), ]
for (i in vars()) {
  puf.d[, i] <- univariate.dis(puf.d, data = ss, i, "rb050")
}

## h-file: household data 
puf.h <- puf[!duplicated(puf$db030),substring(names(puf),1,1)=="h"]
for (i in vars(char1 = "hb", p = puf.h)) {
  puf.h[, i] <- univariate.dis(puf.h, ss , i ,"rb050")
}

hgrossIncome5 <- quantile(puf[!duplicated(puf$db030),"hgrossIncome"],probs=seq(0,1,0.2))
hgrossIncome5[1] <- -Inf
hgrossIncome5[6] <- Inf
if(country == "Austria"){
  suf$hgrossIncome <- rowSums(suf[, c("hy040g","hy050g","hy060g",
          "hy070g", "hy080g", "hy090g", "hy110g")], na.rm = TRUE)
}
suf$hgrossIncome5 <- cut(suf$hgrossIncome, breaks=hgrossIncome5, labels=seq(1,5,1))
puf.h$hgrossIncome5 <- cut(puf.h$hgrossIncome, breaks=hgrossIncome5, labels=seq(1,5,1))
ss <- suf[!duplicated(suf$db030), ]
for (i in vars("hh", puf.h)) {
  puf.h[, i] <- conditional.dis(puf.h, suf[!duplicated(suf$db030),], i,
                           "hgrossIncome5","rb050")
}
for (i in vars("hs", puf.h)) {
  puf.h[, i] <- conditional.dis(puf.h, ss, i,
                           "hgrossIncome5","rb050")
}
vars("hs", puf.h)
colnames(puf.h)
for (i in vars("h", puf.h)) {
  puf.h[, i] <- univariate.dis(puf.h, ss, i, "rb050")
}

## r-file: personal register
puf.r <- puf[,substring(names(puf), 1, 1) == "r"]
for (i in vars("r", puf.r, suf.r)) {
  puf.r[, i] <- univariate.dis(puf.r, suf.r, i,"rb050")
}

## adjustment of year of birth
puf.r$rb080 <- as.numeric(as.character(puf.r$rb010)) - 1 - puf.r$rx020

## p-file: personal data 
puf.p <- puf[which(puf$px020 > 15),substring(names(puf),1,1)=="p"]
s2 <- suf[which(suf$px020 > 15), ]
for (i in vars("pb", puf.p)) {
  puf.p[, i] <- univariate.dis(puf.p, s2, i ,"pb040")
}

pgrossIncome5 <- quantile(puf.p[,"pgrossIncome"],probs=seq(0,1,0.2))
pgrossIncome5[1] <- -Inf
pgrossIncome5[6] <- Inf
puf.p$pgrossIncome5 <- cut(puf.p[,"pgrossIncome"], breaks=pgrossIncome5, 
                         labels=seq(1,5,1))

if(country == "Austria"){
suf$pgrossIncome <- rowSums(suf[, c("py010g","py021g","py050g","py080g",
        "py090g","py100g", "py110g","py120g", "py130g","py140g")], na.rm = TRUE)
}
suf$pgrossIncome5 <- cut(suf$pgrossIncome, breaks=pgrossIncome5, labels=seq(1,5,1))
s2 <- suf[which(suf$px020 > 15), ]
for (i in vars("pe", "puf.p")) {
  puf.p[, i] <- conditional.dis(puf.p, s2, i,
                           "pgrossIncome5","pb040")
}
for (i in vars("ph", puf.p)) {
  puf.p[, i] <- conditional.dis(puf.p, s2, i,
                           "pgrossIncome5","pb040")
}
for (i in vars("pl", puf.p)) {
  puf.p[, i] <- conditional.dis(puf.p, s2, i,
                           "pgrossIncome5","pb040")
}
for (i in vars("p", puf.p)) {
  puf.p[, i] <- univariate.dis(puf.p, s2, i, "pb040")
}

## adjustment of year of birth
puf.p$pb140 <- as.numeric(as.character(puf.p$pb010)) - 1 - puf.p$px020

## second digit of occupation (pl051)
puf.p$pl051.1d <- puf.p$pl051
suf$pl051.1d <- as.factor(trunc(suf$pl051/10))
library("plyr")
if(country == "Austria"){
  cat("some modifications due to combined level at the beginning")
  suf$pe040 <- factor(suf$pe040)
  puf.p$pe040 <- factor(puf.p$pe040) 
  suf$pl051.1d <- revalue(suf$pl051.1d, c("0"="0-1", "1"="0-1" ))
  suf$pe040 <- revalue(suf$pe040, c("0"="0-1", "1"="0-1" ))
} 

suf$pl051 <- factorNA(as.factor(suf$pl051), newval = "NAs")
suf$pl051.1d <- factorNA(suf$pl051.1d, newval = "NAs")
puf.p$pl051.1d <- factorNA(puf.p$pl051.1d, newval = "NAs")
puf.p[, "pl051"] <- conditional.dis(puf.p, suf[which(suf$px020>15),],
                           additional = "pl051", conditional = "pl051.1d", 
                         weights = "pb040", fNA = "NAs")
@

<<echo = FALSE>>=
rm(hgrossIncome5,pgrossIncome5,i,var.d,var.h,var.hb,var.hh,var.hs,var.p,
   var.pb,var.pe,var.ph,var.pl,var.r)
@


Next some additional recoding is required in order to have the same level of details than in the scientific use file. This is only necessary for variables generated in the section \ref{sec:simul}. All other variables are simulated from the scientific use file and therefore no additional recoding is necessary for them.
Further anonymization is only necessary for variables that are not drawn from
 the suf distributions.

<<cache=TRUE>>=
#year of birth:
min <- as.numeric(as.character(puf.p$pb010))[1]-81
puf.p$pb140[which(puf.p$pb140<min)] <- min
puf.r$rb080[which(puf.r$rb080<min)] <- min

#age:
max <- 80
puf.r$rx010[which(puf.r$rx010>max)] <- max
puf.r$rx020[which(puf.r$rx020>max)] <- max
puf.p$px020[which(puf.p$px020>max)] <- max
@

<<echo = FALSE>>=
if(country == "Austria"){
  rm(hminuscomponents, keep, max, min)
} else {
  rm(age.dif, hminuscomponents, keep, max, min)
}
@


Finally for variables simulated in Section~\ref{sec:simul} country specific anonymization rules have to be applied. For example in the German data db040 (NUTS) is not provided and pb220a (citizenship 1) is recoded.



At this point we get $4$ synthetic datasets that mimics the $4$ scientific use files disseminated to researchers ($2$ files for household data, $2$ files for personal data). Simulation process is now over. Further main step is assessment of data utility in resulting datasets after saving all datasets, either in R binary data sets via

<<echo = TRUE>>=
if(country == "Austria"){
  filename <- paste0("~/workspace/sga_sdc/silcPop/simData", year, ".RData")
  save(suf.d, suf.p, suf.r, suf.h, #suf.hh, 
       puf.d, puf.p, puf.r, puf.h,
       puf, suf, eusilc, file = filename)
}
@


or in comma separated files

<<saveCsvs, eval=TRUE, cache=TRUE, include = TRUE, echo=FALSE, eval=FALSE>>=
if(country == "FRANCE"){
  setwd("Z:/Eurostat/FPA/Donn?es/SILC 2012/PUFs")
}
write.csv(x = puf, file = "puf_SILC2012.csv", col.names = TRUE)
write.csv(x = puf.p, file = "puf_p_SILC2013.csv", col.names = TRUE)
write.csv(x = puf.h, file = "puf_h_SILC2013.csv", col.names = TRUE)
write.csv(x = puf.r, file = "puf_r_SILC2013.csv", col.names = TRUE)
write.csv(x = puf.d, file = "puf_d_SILC2013.csv", col.names = TRUE)

## optionally one may also save the suf, 
## since a few modifications were done
write.csv(x = suf, file = "suf_SILC2012.csv", col.names = TRUE)
write.csv(x = suf.p, file = "suf_p_SILC2013.csv", col.names = TRUE)
write.csv(x = suf.h, file = "suf_h_SILC2013.csv", col.names = TRUE)
write.csv(x = suf.r, file = "suf_r_SILC2013.csv", col.names = TRUE)
write.csv(x = suf.d, file = "suf_d_SILC2013.csv", col.names = TRUE)
@

<<saveAustria, echo = FALSE>>=
if(country == "Austria") save.image("image.RData")
@


\section{Final cleaning}

In this section the public-use-files are adapted in such a sense that they mimic the scientific use files from Eurostat. To achieve this goal it is needed that specific variables that have been simulated for simulation purposes are deleted as well as to delete possible duplicated variables. In addition variables computed by Eurostat for the scientific use files are also deleted (all ``X'' and ``hd'' variables).


<<remove vars>>=
## (add variable names that you don't want to have included)
remove_vars <- function(x, 
                        delete = c("hgrossminusCat", "pgrossIncomeCat",
                                   "hgrossIncomeCat", "db062",
                                    "hgrossIncome", "hgrossminus",
                                    "pgrossIncome", "hgrossIncome5",
                                    "pgrossIncome5", "pl051.1d",
                                    "X", "X.1", "hsize"), 
                        deletesub = c("hx", "rx", "px"),
                        duplicated = c("hsize", "hid", "pid")){
  ss <- !(substr(names(x), 1, 2) %in% substr(deletesub, 1, 2)) & 
                    !(names(x) %in% delete) & !(names(x) %in% duplicated)
  return(x[, ss])
}

puf.p <- remove_vars(puf.p)  
puf.h <- remove_vars(puf.h)  
puf.d <- remove_vars(puf.d)  
puf.r <- remove_vars(puf.r)  
suf.p <- remove_vars(suf.p)  
suf.h <- remove_vars(suf.h)  
suf.d <- remove_vars(suf.d)  
suf.r <- remove_vars(suf.r)  
@

Since gender (variable \code{RB090}) is coded as \textit{female} and \textit{male} but in the SUF it is coded as 1 and 2, we change the PUF accordingly.


<<>>=
require("plyr")
puf.r$rb090 <- revalue(puf.r$rb090, c("male" = 1, "female" = 2)) 
puf.p$pb150 <- revalue(puf.p$pb150, c("male" = 1, "female" = 2)) 
@

Eurostat requested to round income variables to two digits since the SUF is also rounded.

<<round>>=
# Household income variables HYxxx
HIncomeVariables <- subset(colnames(puf.h), 
                           substr(colnames(puf.h),1,2) %in% c("hy"))
for (i in HIncomeVariables){
  puf.h[,which(colnames(puf.h)==i)] <- 
    round(as.numeric(puf.h[,which(colnames(puf.h)==i)],digits=2))
}
# Personal income variables PYxxx
PIncomeVariables <- subset(colnames(puf.p), 
                           substr(colnames(puf.p),1,2) %in% c("py"))
for (i in PIncomeVariables){
  puf.p[,which(colnames(puf.p)==i)] <- 
    round(as.numeric(puf.p[,which(colnames(puf.p)==i)],digits=2))
}
@


We format personal ID, if \code{Hb030=100 --> RB030 = 10001}, not \code{100.1}. This is not the case with the Austrian data, but for other data set you might have to achieve this by

<<id>>=
if(country == "France"){
require("stringr")
strip <- function(x){
  l <- str_length(x)
  p <- str_locate(x, "[.]")[1]
  y <- str_sub(x, 1, p-1)
  if (p+1 == l) y <- paste(y, "0", sep = "")
  return(paste(y, str_sub(x, p+1, -1), sep = ""))
}
puf_p$pb030 <- sapply(puf.p$pb030, strip)
puf_r$rb030 <- sapply(puf.r$rb030, strip)
}
@

To mimic the SUF variables, we add variables to the PUF that are not present in the PUF. These variables will containing missing values only.

First we delete unnecessary variables from the SUF

<<>>=
suf.d <- remove_vars(suf.d, delete = c("X", "X.1"), 
                     deletesub = c(""), duplicated = c(""))
suf.h <- remove_vars(suf.h, delete = c("X", "X.1"), 
                     deletesub = c(""), duplicated = c(""))
suf.p <- remove_vars(suf.p, delete = c("X", "X.1"), 
                     deletesub = c(""), duplicated = c(""))
suf.r <- remove_vars(suf.r, delete = c("X", "X.1"), 
                     deletesub = c(""), duplicated = c(""))
@

The following function add variables that are in the SUF but not in the PUF.

<<missVars>>=
addMissingVars <- function(puf = puf.d, suf = suf.d) {
  # Names of variables in PUF and SUD
  listVarSUF <- colnames(suf)
  listVarPUF <- colnames(puf)
  
  for (i in listVarSUF) {
    if (i %in% listVarPUF) {
      # Do nothing if already simulated
      puf <- puf
    } else {
      ## USE blank values for the new (non-simulated) column
      newCol <- rep(NA, nrow(puf))
      puf<- data.frame(puf, newCol)
      ## Add the good name to the column
      colnames(puf)[which(names(puf) == "newCol")] <- i
    }
  }
  return(puf)
}
@

<<addMissvarsaction>>=
puf.p <- addMissingVars(puf.p, suf.p)  
puf.h <- addMissingVars(puf.h, suf.h)  
puf.d <- addMissingVars(puf.d, suf.d)  
puf.r <- addMissingVars(puf.r, suf.r)   
@



The variable \code{db090} should be added if not present.

<<>>=
if(country == "France"){
weight <- unique(data.frame(
  id=as.numeric(as.character(substr(puf.r$rb030, 1, nchar(puf.r$rb030) - 2))), 
  weight = puf.r$rb050))
puf.d$db090 <- weight$weight
}
@


As last step we ensure that the variables have the same order as in the SUF.
To ensure this, we simple take alphabetic order.

<<alphabetic>>=
puf.p <- puf.p[, colnames(suf.p)] 
puf.h <- puf.h[, colnames(suf.h)] 
puf.d <- puf.d[, colnames(suf.d)] 
puf.r <- puf.r[, colnames(suf.r)] 
@

Since the variables in the SUF are in captial letters, we also achieve this in the PUF.

<<uppercase>>=
names(puf.p) <- toupper(names(puf.p))
names(puf.h) <- toupper(names(puf.h))
names(puf.d) <- toupper(names(puf.d))
names(puf.r) <- toupper(names(puf.r))
@

The data files are now written as \code{.csv}. The missing code is changed to mimic the SUF.

<<writefilesfinal>>=
puf.p$pl051 <- revalue(puf.p$pl051, c("NAs"=NA))
where <- "/data/home/templ/workspace/sga_sdc/silcPop/"
write.csv(puf.p, file = paste0(where, "puf_p_SILC2013.csv"), na = "")
write.csv(puf.h, file = paste0(where, "puf_h_SILC2013.csv"), na = "")
write.csv(puf.d, file = paste0(where, "puf_d_SILC2013.csv"), na = "")
write.csv(puf.r, file = paste0(where, "puf_r_SILC2013.csv"), na = "")
@

Optionally one may also save the SUF.

<<writefilesfinal2>>=
write.csv(x = suf, file = paste0(where, "suf_SILC2013.csv"), 
          col.names = TRUE, na = "")
write.csv(x = suf.p, file = paste0(where, "suf_p_SILC2013.csv"), 
          col.names = TRUE, na = "")
write.csv(x = suf.h, file = paste0(where, "suf_h_SILC2013.csv"), 
          col.names = TRUE, na = "")
write.csv(x = suf.r, file = paste0(where, "suf_r_SILC2013.csv"), 
          col.names = TRUE, na = "")
write.csv(x = suf.d, file = paste0(where, "suf_d_SILC2013.csv"), 
          col.names = TRUE, na = "")
@


\bibliography{eusilcSynth}


\end{document}